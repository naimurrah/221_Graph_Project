        -:    0:Source:graph.h
        -:    0:Graph:graph_tests.gcno
        -:    0:Data:graph_tests.gcda
        -:    0:Runs:1
        -:    1:#ifndef GRAPH_H
        -:    2:#define GRAPH_H
        -:    3:
        -:    4:#include <list>
        -:    5:#include <unordered_set>
        -:    6:#include <unordered_map>
        -:    7:#include <cmath>
        -:    8:#include <iostream>
        -:    9:#include <queue>
        -:   10:
        -:   11:class Graph
        -:   12:{
        -:   13:private:
        -:   14:    // TODO(student): implement graph
        -:   15:    // struct Edge;
        -:   16:
        -:   17:    struct Vertex
        -:   18:    {
        -:   19:        /*
        -:   20:        each verte holds a value
        -:   21:        a vertex knows its neighbours, to do this, use a vector<Vertex>
        -:   22:        a vertex also has an edge, and an edge is simple a source and a destination
        -:   23:        */
        -:   24:        size_t id;
        -:   25:
        -:   26:        size_t index;
        -:   27:        std::vector<size_t> neigh_index; // indices of the neigh_index;
        -:   28:        // std::vector<Edge> edges;
        -:   29:
        -:   30:        // pretty sure these are used during traversal.
        -:   31:        bool visited;
        -:   32:        int distance;
        -:   33:        Vertex *previous;
        -:   34:        // &Edge find edge(Vertex destination) // returns an edge with this being point a and destination point b
        -:   35:
        -:   36:        // vertex constructor
        7:   37:        Vertex(size_t i, size_t in, size_t d = std::numeric_limits<int>::max(), bool v = false) : id(i), index(in), neigh_index(), visited(v), distance(d), previous(nullptr) {}
        -:   38:        Vertex(Vertex &other) : id(other.id), index(other.index), neigh_index(other.neigh_index), visited(other.visited), distance(other.distance), previous(other.previous) {}
        -:   39:
        -:   40:        Vertex &operator=(const Vertex &other)
        -:   41:        {
        -:   42:            if (this != &other)
        -:   43:            {
        -:   44:                id = other.id;
        -:   45:                index = other.index;
        -:   46:                neigh_index = other.neigh_index;
        -:   47:                visited = other.visited;
        -:   48:                distance = other.distance;
        -:   49:                previous = nullptr; // look  at this later
        -:   50:            }
        -:   51:            return *this;
        -:   52:        }
        -:   53:
        -:   54:        ~Vertex()
        -:   55:        {
        -:   56:            previous = nullptr;
        -:   57:            neigh_index.clear();
        -:   58:        }
        -:   59:    };
        -:   60:
        -:   61:    // Struct for an edge
        -:   62:    /*
        -:   63:    An edge contains its start and end points and the weight of the edge as well.
        -:   64:
        -:   65:    */
        -:   66:    /*
        -:   67:    struct Edge
        -:   68:    {
        -:   69:        Vertex start;
        -:   70:        Vertex end;
        -:   71:        size_t weight;
        -:   72:        Edge(Vertex s, Vertex e, size_t w) : start(s), end(e), weight(w) {}
        -:   73:    };
        -:   74:    */
        -:   75:
        -:   76:    // unordered set to keep count of vertices presenent
        -:   77:    std::unordered_set<size_t> id_set{}; // using this so when using contains we could easly check if its in the set. Each id will be unique
        -:   78:    // List of some sort to hold the vertices in the graph
        -:   79:    std::vector<Vertex *> vertices{};
        -:   80:
        -:   81:    // Maybe add -
        -:   82:    std::vector<std::vector<size_t>> weights{};
        -:   83:    /*0
        -:   84:    0 0
        -:   85:    */
        -:   86:    size_t v_count; // vertex count
        -:   87:    size_t e_count; // edge count
       48:   88:    size_t find_vertex_index(size_t id) const
        -:   89:    {
      168:   90:        for (Vertex *v : vertices)
        -:   91:        {
      168:   92:            if (v->id == id)
        -:   93:            {
       48:   94:                return v->index;
        -:   95:            }
        -:   96:        }
    #####:   97:        return 10000000;
        -:   98:    }
        -:   99:
        -:  100:public:
        -:  101:    // Task 1
        -:  102:    // start
        1:  103:    Graph() : v_count(0), e_count(0){};
        -:  104:    Graph(const Graph &other) : id_set(other.id_set), vertices(other.vertices), weights(other.weights), v_count(other.v_count), e_count(other.e_count){};
        -:  105:    Graph &operator=(const Graph &other)
        -:  106:    {
        -:  107:        if (this != &other)
        -:  108:        {
        -:  109:            this->id_set = other.id_set;
        -:  110:            this->vertices = other.vertices;
        -:  111:            this->weights = other.weights;
        -:  112:            this->v_count = other.v_count;
        -:  113:            this->e_count = other.e_count;
        -:  114:        }
        -:  115:        return *this;
        -:  116:    };
        1:  117:    ~Graph()
        1:  118:    {
        1:  119:        id_set.clear();
        1:  120:        vertices.clear();
        1:  121:        weights.clear();
        1:  122:        v_count = 0;
        1:  123:        e_count = 0;
        1:  124:    };
        -:  125:
        1:  126:    size_t vertex_count() const
        -:  127:    {
        1:  128:        return v_count;
        -:  129:    };
        1:  130:    size_t edge_count() const
        -:  131:    {
        1:  132:        return e_count;
        -:  133:    };
        -:  134:
        7:  135:    bool contains_vertex(size_t id) const
        -:  136:    {
        7:  137:        return !(id_set.find(id) == id_set.end());
        -:  138:    }
        -:  139:
       12:  140:    bool contains_edge(size_t src, size_t dest) const
        -:  141:    {
       12:  142:        size_t src_i = find_vertex_index(src);
       12:  143:        size_t dest_i = find_vertex_index(dest);
        -:  144:
       12:  145:        return weights[src_i][dest_i] != 0;
        -:  146:    }
        -:  147:
        -:  148:    double cost(size_t src, size_t dest) const
        -:  149:    {
        -:  150:        if (weights[src][dest] == 0)
        -:  151:            return std::numeric_limits<int>::max();
        -:  152:        return weights[src][dest];
        -:  153:    };
        -:  154:
        -:  155:    /*0 1
        -:  156:    0 0 0
        -:  157:    1 2 0
        -:  158:    */
        7:  159:    bool add_vertex(size_t id)
        -:  160:    {
        -:  161:
        7:  162:        if (contains_vertex(id))
        -:  163:        {
    #####:  164:            return false;
        -:  165:        }
        -:  166:
        7:  167:        Vertex *new_vertex = new Vertex(id, v_count);
        7:  168:        vertices.emplace_back(new_vertex);
        7:  169:        std::vector<size_t> newRow(v_count + 1);
        7:  170:        weights.emplace_back(newRow);
        7:  171:        id_set.insert(id);
        -:  172:
       28:  173:        for (size_t i = 0; i < weights.size() - 1; i++)
        -:  174:        {
       21:  175:            weights[i].resize(v_count + 1);
        -:  176:        }
        -:  177:
        7:  178:        v_count++;
        7:  179:        return true;
        -:  180:    }
        -:  181:
       12:  182:    bool add_edge(size_t src, size_t dest, double weight = 1)
        -:  183:    {
       12:  184:        if (contains_edge(src, dest))
        -:  185:        {
    #####:  186:            return false;
        -:  187:        }
       12:  188:        size_t src_i = find_vertex_index(src);
       12:  189:        size_t dest_i = find_vertex_index(src);
       12:  190:        weights[src_i][dest_i] = weight;
        -:  191:        // add neighbhor to both vertices
        -:  192:
       12:  193:        return true;
        -:  194:    }
        -:  195:
        -:  196:    bool remove_vertex(size_t id)
        -:  197:    {
        -:  198:        if (!contains_vertex(id))
        -:  199:        {
        -:  200:            return false;
        -:  201:        }
        -:  202:        size_t index = find_vertex_index(id);
        -:  203:        id_set.erase(id_set.find(id));
        -:  204:
        -:  205:        Vertex *del = std::move(vertices[index]);
        -:  206:        delete del;
        -:  207:
        -:  208:        for (size_t i = index; i < vertices.size() - 1; i++)
        -:  209:        {
        -:  210:            vertices[i] = std::move(vertices[i + 1]);
        -:  211:            vertices[i]->index = vertices[i]->index - 1;
        -:  212:            // remove neighbor if exists
        -:  213:        }
        -:  214:        vertices.pop_back();
        -:  215:        weights.pop_back();
        -:  216:
        -:  217:        for (size_t i = 0; i < weights.size(); i++)
        -:  218:        {
        -:  219:            auto remove = weights[i].begin() + index;
        -:  220:            weights[i].erase(remove);
        -:  221:        }
        -:  222:
        -:  223:        v_count--;
        -:  224:        return true;
        -:  225:    }
        -:  226:
        -:  227:    bool remove_edge(size_t src, size_t dest)
        -:  228:    {
        -:  229:        if (!contains_edge(src, dest))
        -:  230:        {
        -:  231:            return false;
        -:  232:        }
        -:  233:        size_t src_i = find_vertex_index(src);
        -:  234:        size_t dest_i = find_vertex_index(dest);
        -:  235:
        -:  236:        weights[src_i][dest_i] = 0;
        -:  237:        e_count--;
        -:  238:        return true;
        -:  239:    };
        -:  240:
        -:  241:    // Task 2
        -:  242:    void prim(size_t source_id);
        -:  243:    bool is_path(size_t id) const;
        -:  244:    void print_path(size_t dest_id, std::ostream &os = std::cout) const;
        -:  245:
        -:  246:    // Task 3
        -:  247:    void dijkstra(size_t source_id);
        -:  248:    double distance(size_t id) const;
        -:  249:    void print_shortest_path(size_t dest_id, std::ostream &os = std::cout) const;
        -:  250:};
        -:  251:
        -:  252:#endif // GRAPH_H
